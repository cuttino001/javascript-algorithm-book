# 一些知识点

## 数组

- js 中的数组不一定是连续的内存空间，可能是一个 hash 映射分配的内存空间，对象由链表来表示
- 数组中，我们直接访问索引、可以做到一步到位，这个操作的复杂度会被降级为常数级别(O(1))：

## 链表

链表也有一个弊端：当我们试图读取某一个特定的链表结点时，必须遍历整个链表来查找它。比如说我要在一个长度为 n（n>10） 的链表里，定位它的第 10 个结点，我需要这样做：

```javascript
// 记录目标结点的位置
const index = 10;
// 设一个游标指向链表第一个结点，从第一个结点开始遍历
let node = head;
// 反复遍历到第10个结点为止
for (let i = 0; i < index && node; i++) {
  node = node.next;
}
```

随着链表长度的增加，我们搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高。这个变化的趋势呈线性规律，用大 O 表示法表示为 O(n)。

所以说链表的插入/删除效率较高，而访问效率较低；数组的访问效率较高，而插入效率较低。这个特性需要大家牢记，可能会作为数据结构选型的依据来单独考察。

- dummy 结点在链表当中常用，建议涉及到链表操作的都加上 dummy 节点
- 倒数变成整数，也是经常采用的方案。

## 二叉树

二叉树是指满足以下要求的树：
它可以没有根结点，作为一棵空树存在
如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。

## （在前端算法面试中）什么样的题目是好题？

首先，不能剑走偏锋：好的面试题，它考察的大多是算法/数据结构中最经典、最关键的一部分内容，这样才能体现公平；其次，它的知识点要尽可能密集、题目本身要尽可能具备综合性，这样才能一箭双雕甚至一箭 N 雕，进而体现区分度、最大化面试过程的效率。

能够同时在这两个方面占尽优势的考题其实并不是很多，“用栈实现队列”这样的问题算是其中的佼佼者：一方面，它考察的确实是数据结构中的经典内容；另一方面，它又覆盖了两个大的知识点、足以检验出候选人编码基本功的扎实程度。唯一的 BUG 可能就是深度和复杂度不够，换句话说就是不够难。

这个特点，在普通算法面试中可能是 BUG，但在前端算法面试中，实在未必。大家要知道，你是前端，你的面试官也是前端，前端行业普遍的算法水平是啥样他心里还没个数吗...... 实际上大多数前端算法面试题的风格都是非常务实的，需要你炫技的实属特殊情况。

## 技巧

- 所有的求和基本都能变成求差
- 什么时候你需要联想到对撞指针？“有序”和“数组”,见到这两个关键字，立刻把双指针法调度进你的大脑内存。普通双指针走不通，立刻想对撞指针！
- 以后只要分析出重复的逻辑（排除掉类似数组遍历这种简单粗暴的重复），你都需要把递归从你的大脑内存里调度出来、将其列为“可以一试”的解法之一；只要想到递归，立刻回忆我们上一节讲的 DFS 思想、然后尝试套我们这一节末尾教给大家的解题模板。这个脑回路未必 100% 准确，但确实有极高的成功概率——题，是有规律的。这，就是规律之一

---

一些二叉树的题目暂未列出来

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。
许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。
